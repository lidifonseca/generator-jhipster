<%_ let result = ''; _%>
<%_ const formLayoutInputMask = typeof field.formLayoutInputMask !== 'undefined' && field.formLayoutInputMask.trim() ? true : false; _%>
<%_ 
if (field.fieldValidate === true) {
	const rules = field.fieldValidateRules;
	const validators = [];

    if (rules.includes('required') && field.fieldType !== 'Boolean') {
        validators.push('required: { value: true, errorMessage: translate(\'entity.validation.required\') }');
    }
    if (rules.includes('minlength') && !formLayoutInputMask) {
        validators.push('minLength: { value: ' + field.fieldValidateRulesMinlength + ', errorMessage: translate(\'entity.validation.minlength\', { min: ' + field.fieldValidateRulesMinlength + ' }) }');
    }
    if (rules.includes('maxlength') && !formLayoutInputMask) {
        validators.push('maxLength: { value: ' + field.fieldValidateRulesMaxlength + ', errorMessage: translate(\'entity.validation.maxlength\', { max: ' + field.fieldValidateRulesMaxlength + ' }) }');
    }
    if (rules.includes('min') && !formLayoutInputMask) {
        validators.push('min: { value: ' + field.fieldValidateRulesMin + ', errorMessage: translate(\'entity.validation.min\', { min: ' + field.fieldValidateRulesMin + ' }) }');
    }
    if (rules.includes('max') && !formLayoutInputMask) {
        validators.push('max: { value: ' + field.fieldValidateRulesMax + ', errorMessage: translate(\'entity.validation.max\', { max: ' + field.fieldValidateRulesMax + ' }) }');
    }
    if (rules.includes('pattern')) {
        validators.push('pattern: { value: \'' + field.fieldValidateRulesPatternReact.replace(/\\/g, '\\\\') + '\', errorMessage: translate(\'entity.validation.pattern\', { pattern: \'' + field.fieldValidateRulesPatternReact.replace(/\\/g, '\\\\') + '\' }) }');
    }
    if (['Integer', 'Long', 'Float', 'Double', 'BigDecimal'].includes(field.fieldType)) {
        validators.push('number: { value: true, errorMessage: translate(\'entity.validation.number\') }');
    }
    // Not supported anymore because the server can't check the size of the blob before downloading it completely.
    // if (rules.includes('minbytes')) {
    //     validators.push('minbytes: { value: ' + field.fieldValidateRulesMinbytes + ', errorMessage: translate(\'entity.validation.minbytes\', { min: ' + field.fieldValidateRulesMinbytes + ' }) }');
    // }
    // if (rules.includes('maxbytes')) {
    //     validators.push('maxbytes: { value: ' + field.fieldValidateRulesMaxbytes + ', errorMessage: translate(\'entity.validation.maxbytes\', { min: ' + field.fieldValidateRulesMaxbytes + ' }) }');
    // }

    result = validators.join(',\n                ');
}
-%>
<%- result -%>
